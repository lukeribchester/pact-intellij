{
  parserClass="io.kadena.pact.intellij.language.parser.PactParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Pact"
  psiImplClassSuffix="Impl"
  psiPackage="io.kadena.pact.intellij.language.psi"
  psiImplPackage="io.kadena.pact.intellij.language.psi.impl"

  elementTypeHolderClass="io.kadena.pact.intellij.language.psi.PactTypes"
  elementTypeClass="io.kadena.pact.intellij.language.psi.PactElementType"
  tokenTypeClass="io.kadena.pact.intellij.language.psi.PactTokenType"

  tokens = [
  // Separators
  LPAREN="("
  RPAREN=")"
  LBRACKET="["
  RBRACKET="]"
  LBRACE="{"
  RBRACE="}"
  DOT="."
  COMMA=","
  COLON=":"
  UNDERSCORE="_"
  // Literals
  // TODO: Finalise and create identifier token.
  STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
  SYMBOL="regexp:`\w+"
  INTEGER="regexp:([0-9])"
  DECIMAL=""
  BOOLEAN="regexp:(true|false)"
  // Documentation
  DOC="@doc"
  MODEL="@model"
  COMMENT="regexp:(;)[^\r\n]*"
  // Special forms
  BLESS="bless"
  DEFUN="defun"
  DEFCAP="defcap"
  DEFCONST="defconst"
  DEFPACT="defpact"
  DEFSCHEMA="defschema"
  DEFTABLE="deftable"
  LET="let"
  LET_STAR="let*"
  COND="cond"
  STEP="step"
  STEP_WITH_ROLLBACK="step-with-rollback"
  USE="use"
  INTERFACE="interface"
  NAMESPACE="namespace"
  MODULE="module"
  IMPLEMENTS="implements"
  // Numerical operators
  ADD="+"
  SUB="-"
  MULT="*"
  DIV="/"
  CARET="^"
  LOG="log"
  SQRT="sqrt"
  LN="ln"
  EXP="exp"
  ABS="abs"
  ROUND="round"
  CEILING="ceiling"
  FLOOR="floor"
  MOD="mod"
  // Bitwise operators
  AMP="&"
  PIPE="|"
  XOR="xor"
  SHIFT="shift"
  TILDE="~"
  // Logical operators
  GT=">"
  LT="<"
  GE=">="
  LE="<="
  EQ="="
  EXCL_EQ="!="
  AND="and"
  AND_APP="and?"
  OR="or"
  OR_APP="or?"
  NOT="not"
  NOT_APP="not?"
  WHEN="when"
  // Miscellaneous
  IDENTIFIER="regexp:([a-zA-Z0-9_-]+)"
  ATOM="regexp:([a-zA-Z0-9_-]+)"
  CRLF="regexp:\R"
  WHITE_SPACE="regexp:[\ \n\t\f]"
  ]
}

// A program is a collection of top-level declarations and/or expressions.
// program ::= { defun_decl | namespace_decl | module_decl | interface_decl | expr } * {extends=program}
program ::= { expression } * {extends=program}

// Top-level declarations.
declaration    ::= defun_declaration
                   // namespace_declaration |
                   // module_declaration |
                   // interface_declaration |
namespace_declaration ::= LPAREN NAMESPACE STRING RPAREN
module_declaration    ::= LPAREN MODULE IDENTIFIER module_guard [ doc_or_meta ] [ decl_list ] RPAREN
interface_declaration ::= LPAREN INTERFACE IDENTIFIER [ doc_or_meta ] sig_list RPAREN

sig_list  ::= DEFCONST | defun_sig
decl_list ::= imports decls
imports   ::= LPAREN use_decl RPAREN { LPAREN use_decl RPAREN }
decls     ::=  LPAREN decl RPAREN { LPAREN decl RPAREN }
decl      ::= defun_decl | defconst_decl | defcap_decl | defpact_decl | defschema_decl |
           deftable_decl | bless_decl // TODO: Refactor to special_form_decls?

module_guard ::= IDENTIFIER | kset

defun_sig ::= DEFUN LPAREN fun_args RPAREN [ doc_or_meta ]

// TODO: Next Steps.
// 1. Define an expression.
// https://pact-language.readthedocs.io/en/stable/pact-reference.html#expressions
// 2. Handle escaped strings.
// TODO: Finalise. STRING = Docs or metadata.
defun_declaration ::= LPAREN DEFUN IDENTIFIER [ LPAREN (fun_args) RPAREN ] [ STRING ] expr RPAREN

// ########## EXPRESSION / START ##########
expression ::= literal | atoms | s_expression | reference

atoms ::= ATOM | SYMBOL | let_bind | let_star_bind
symbol_expression ::= (LPAREN s_expression { s_expression } RPAREN) | atoms
reference ::= atoms [ '.' reference ]

// ########## LITERAL / START ##########

literal ::= string_literal |
            symbol_literal |
            integer_literal |
            decimal_literal |
            boolean_literal |
            list_literal |
            object_literal |
            binding_literal |
            lambda_literal

string_literal ::= STRING
symbol_literal ::= SYMBOL
integer_literal ::= [ SUB ] numbers
decimal_literal ::= [ SUB ] numbers DOT numbers
boolean_literal ::= 'true' | 'false'
list_literal ::= 'TODO'
object_literal ::= LBRACE key_value { COMMA key_value } RBRACE
binding_literal ::= 'TODO'
lambda_literal ::= 'TODO'

number ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
numbers ::= number { number }

key_value ::= '"' IDENTIFIER '"' COLON expression

// ########## LITERAL / END ##########

// ########## END ##########

defconst_decl ::= DEFCONST IDENTIFIER expr
defcap_decl ::= DEFCAP IDENTIFIER LPAREN fun_args RPAREN [ doc_or_meta ] expr
defpact_decl ::= DEFPACT IDENTIFIER LPAREN fun_args RPAREN [ doc_or_meta ] { step_decl }
defschema_decl ::= DEFSCHEMA IDENTIFIER [ doc_or_meta ] fields
deftable_decl ::= DEFTABLE IDENTIFIER [COLON IDENTIFIER] [ doc_or_meta ]
bless_decl ::= BLESS hash
use_decl ::= USE IDENTIFIER
implements_decl ::= IMPLEMENTS IDENTIFIER
step_decl ::= LPAREN STEP [ string_lit ] expr RPAREN
 | LPAREN STEP_WITH_ROLLBACK [ string_lit ] expr expr RPAREN

fields ::= { field }
field ::= IDENTIFIER COLON IDENTIFIER

fun_args ::= arg { arg } *
arg ::= IDENTIFIER [ COLON IDENTIFIER ]

// Documentation for defuns and modules
doc_or_meta ::= doc mta | mta | ε
doc         ::= '@doc' STRING
mta         ::= '@model' LBRACKET models RBRACKET
models      ::=  property models | invariant models | models | ε
property    ::= LPAREN 'property' expr RPAREN
invariant   ::= LPAREN 'invariant' expr RPAREN

// Expressions. note: expr lists are nonempty, as () in lisp is nil literal
//expr         ::= LPAREN ne_expr_list RPAREN | atom
//ne_expr_list ::= expr { expr }

atom     ::= type_ann | let_bind | let_star_bind | atom2
type_ann ::= LPAREN expr COLON IDENTIFIER RPAREN
let_bind ::= LPAREN LET (single_bind | multi_bind) expr RPAREN
let_star_bind ::= LPAREN LET_STAR (single_bind | multi_bind) expr RPAREN
single_bind ::= LPAREN IDENTIFIER expr RPAREN
multi_bind ::= LPAREN single_bind { single_bind } RPAREN
atom2    ::= IDENTIFIER | lit | op

// All literals TODO: Refactor
lit ::= string_lit | symbol | integer | decimal | bool
     bool | list_lit | object_lit | table | kset

//string_lit           ::= ('"') + string_lit_t + ('"')
//string_lit_t         ::= 'free'
//symbol               ::= "`" IDENTIFIER
//bool                 ::= 'true' | 'false'
//integer              ::= [ SUB ] numbers
//decimal              ::= [ SUB ] numbers DOT numbers
list_lit             ::= LBRACKET { expr } RBRACKET | LBRACKET expr { COMMA expr } RBRACKET
comma_delimited_list ::= expr comma_delimited_rest | ε
comma_delimited_rest ::= COMMA expr | ε
//object_lit           ::= LBRACE kv { COMMA kv } RBRACE
//kv                   ::= '\"' IDENTIFIER '\"' COLON expr
kset                 ::= hashes | LBRACE 'keys' COLON hashes RBRACE | LBRACE 'keys' COLON hashes COMMA 'pred' COLON pred RBRACE
pred                 ::= 'keys-all' | 'keys-1' | 'keys-2'

alphanumeric ::= uc_letter | lc_letter | number
//uc_letter ::= 'A' | ' ...' | 'Z'
//lc_letter ::= 'a' | ' ...' | 'z'

op ::= // Printable operators
hash ::= { alphanumeric } // This is base64-encoded
hashes ::= LBRACKET { hash } RBRACKET
