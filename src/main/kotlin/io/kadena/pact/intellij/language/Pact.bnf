{
  parserClass="io.kadena.pact.intellij.language.parser.PactParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Pact"
  psiImplClassSuffix="Impl"
  psiPackage="io.kadena.pact.intellij.language.psi"
  psiImplPackage="io.kadena.pact.intellij.language.psi.impl"

  elementTypeHolderClass="io.kadena.pact.intellij.language.psi.PactTypes"
  elementTypeClass="io.kadena.pact.intellij.language.psi.PactElementType"
  tokenTypeClass="io.kadena.pact.intellij.language.psi.PactTokenType"

  tokens = [
  // Separators
  LPAREN="("
  RPAREN=")"
  LBRACKET="["
  RBRACKET="]"
  LBRACE="{"
  RBRACE="}"
  DOT="."
  COMMA=","
  COLON=":"
  UNDERSCORE="_"
  // Literals
  STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
  SYMBOL="regexp:`\w+"
  // Documentation
  DOC="@doc"
  MODEL="@model"
  COMMENT="regexp:(;)[^\r\n]*"
  // Special forms
  BLESS="bless"
  DEFUN="defun"
  DEFCAP="defcap"
  DEFCONST="defconst"
  DEFPACT="defpact"
  DEFSCHEMA="defschema"
  DEFTABLE="deftable"
  LET_BIND="let"
  LET_STAR_BIND="let*"
  COND="cond"
  STEP="step"
  STEP_WITH_ROLLBACK="step-with-rollback"
  USE="use"
  INTERFACE="interface"
  NAMESPACE="namespace"
  MODULE="module"
  IMPLEMENTS="implements"
  // Numerical operators
  ADD="+"
  SUB="-"
  MULT="*"
  DIV="/"
  CARET="^"
  LOG="log"
  SQRT="sqrt"
  LN="ln"
  EXP="exp"
  ABS="abs"
  ROUND="round"
  CEILING="ceiling"
  FLOOR="floor"
  MOD="mod"
  // Bitwise operators
  AMP="&"
  PIPE="|"
  XOR="xor"
  SHIFT="shift"
  TILDE="~"
  // Logical operators
  GT=">"
  LT="<"
  GE=">="
  LE="<="
  EQ="="
  EXCL_EQ="!="
  AND="and"
  AND_APP="and?"
  OR="or"
  OR_APP="or?"
  NOT="not"
  NOT_APP="not?"
  WHEN="when"
  // Miscellaneous
  CRLF="regexp:\R"
  WHITE_SPACE="regexp:[\ \n\t\f]"
  ]
}

// A program is a collection of declarations and expressions
program ::= namespace_decl | module_decl | interface_decl | expr {extends=program}

// Top-level declarations
namespace_decl ::= lparen namespace string_lit rparen // TODO: symbol or identifier
module_decl    ::= lparen module ident module_guard doc_or_meta decl_list rparen
interface_decl ::= lparen interface ident doc_or_meta sig_list rparen

sig_list  ::= defconst | defun_sig
decl_list ::= imports decls
imports   ::= lparen use_decl rparen { lparen use_decl rparen }
decls     ::=  lparen decl rparen { lparen decl rparen }
decl      ::= defun_decl | defconst_decl | defcap_decl | defpact_decl | defschema_decl |
           deftable_decl | bless_decl // TODO: Refactor to special_form_decls?

module_guard ::= ident | kset

defun_sig ::= defun lparen fun_args rparen doc_or_meta
defun_decl ::= defun lparen fun_args rparen doc_or_meta expr
defconst_decl ::= defconst ident expr
defcap_decl ::= defcap ident lparen fun_args rparen doc_or_meta expr
defpact_decl ::= defpact ident lparen fun_args rparen doc_or_meta { step_decl }
defschema_decl ::= defschema ident doc_or_meta fields
deftable_decl ::= deftable ident [colon ident] doc_or_meta
bless_decl ::= bless hash
use_decl ::= use ident
implements_decl ::= implements ident
step_decl ::= lparen step [ string_lit ] expr rparen
 | lparen step_with_rollback [ string_lit ] expr expr rparen

fields ::= { field }
field ::= ident colon ident

fun_args ::= arg arg_rest
arg_rest ::= { arg }
arg ::= ident [colon ident]

// Documentation for defuns and modules
doc_or_meta ::= doc mta | mta | ε
doc         ::= '@doc' string
mta         ::= '@model' lbracket models rbracket
models      ::=  property models | invariant models | models | ε
property    ::= lparen 'property' expr rparen
invariant   ::= lparen 'invariant' expr rparen

// Expressions. note: expr lists are nonempty, as () in lisp is nil literal
expr         ::= lparen ne_expr_list rparen | atom
ne_expr_list ::= expr { expr }

atom     ::= type_ann | let_bind | let_star_bind | atom2
type_ann ::= lparen expr colon ident rparen
let_bind ::= lparen 'let' (single_bind | multi_bind) expr rparen
let_star_bind ::= lparen 'let*' (single_bind | multi_bind) expr rparen
single_bind ::= lparen ident expr rparen
multi_bind ::= lparen single_bind { single_bind } rparen
atom2    ::= ident | lit | op

ident      ::= letter { ('-' | letter | number) }

// All literals TODO: Refactor
lit ::= string_lit | symbol | integer | decimal | bool
     bool | list_lit | object_lit | table | kset

string_lit           ::= '\"' string '\"'
symbol               ::= "`" ident
bool                 ::= 'true' | 'false'
integer              ::= [ sub ] numbers
decimal              ::= [ sub ] numbers dot numbers
list_lit             ::= lbracket { expr } rbracket | lbracket expr { comma expr } rbracket
comma_delimited_list ::= expr comma_delimited_rest | ε
comma_delimited_rest ::= comma expr | ε
object_lit           ::= lbrace kv { comma kv } rbrace
kv                   ::= '\"' ident '\"' colon expr
kset                 ::= hashes | lbrace 'keys' colon hashes rbrace | lbrace 'keys' colon hashes comma 'pred' colon pred rbrace
pred                 ::= 'keys-all' | 'keys-1' | 'keys-2'

numbers ::= number { number }
letter ::= { (uc_letter | lc_letter | underscore ) }
alphanumeric ::= uc_letter | lc_letter | number
uc_letter ::= 'A' | ' ...' | 'Z'
lc_letter ::= 'a' | ' ...' | 'z'
number    ::= '0' | ' ...' | '9'
op ::= // Printable operators
string ::= // All printable characters
hash ::= { alphanumeric } // This is base64-encoded
hashes ::= lbracket { hash } rbracket

// TODO: Remove - Separators and operators
sub ::= '-'

// Separators
lparen ::= '('
rparen ::= ')'
lbracket ::= '['
rbracket ::= ']'
lbrace ::= '{'
rbrace ::= '}'
dot ::= '.'
comma ::= ','
colon ::= ':'
underscore ::= '_'

// Literals
string ::=
symbol ::=

// Documentation
doc ::= '@doc'
model ::= '@model'
comment ::=

// Special forms
special_forms ::= bless
  | defun
  | defcap
  | defconst
  | defpact
  | defschema
  | deftable
  | let_bind
  | let_star_bind
  | cond
  | step
  | step_with_rollback
  | use
  | interface
  | module
  | implements

bless ::= 'bless'
defun ::= 'defun'
defcap ::= 'defcap'
defconst ::= 'defconst'
defpact ::= 'defpact'
defschema ::= 'defschema'
deftable ::= 'deftable'
let_bind ::= 'let'
let_star_bind ::= 'let*'
cond ::= 'cond'
step ::= 'step'
step_with_rollback ::= 'step-with-rollback'
use ::= 'use'
interface ::= 'interface'
namespace ::= 'namespace'
module ::= 'module'
implements ::= 'implements'
