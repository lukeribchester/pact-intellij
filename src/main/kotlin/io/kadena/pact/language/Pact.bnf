{
  parserClass="io.kadena.pact.language.parser.PactParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Pact"
  psiImplClassSuffix="Impl"
  psiPackage="io.kadena.pact.language.psi"
  psiImplPackage="io.kadena.pact.language.psi.impl"

  elementTypeHolderClass="io.kadena.pact.language.psi.PactTypes"
  elementTypeClass="io.kadena.pact.language.psi.PactElementType"
  tokenTypeClass="io.kadena.pact.language.psi.PactTokenType"

  tokens = [
    /* Whitespace */
    CRLF="regexp:\R"
    WHITE_SPACE="regexp:[\ \n\t\f]"

    /* Comments */
    COMMENT="regexp:(;.*\n*)"

    /* Keywords */
    KEYWORD_BLESS="bless"
    KEYWORD_ENFORCE="enforce"
    KEYWORD_ENFORCE_ONE="enforce-one"
    KEYWORD_IF="if"
    KEYWORD_IMPLEMENTS="implements"
    KEYWORD_INTERFACE="interface"
    KEYWORD_LAMBDA="lambda"
    KEYWORD_LET="regexp:(let|let\*)"
    KEYWORD_MODULE="module"
    KEYWORD_BLOCK_INTRO="progn"
    KEYWORD_STEP="step"
    KEYWORD_STEP_WITH_ROLLBACK="step-with-rollback"
    KEYWORD_SUSPEND="suspend"
    KEYWORD_TRY="try"
    KEYWORD_IMPORT="use"

    /* Keywords (Capabilities) */
    KEYWORD_CREATE_USER_GUARD="create-user-guard"
    KEYWORD_WITH_CAPABILITY="with-capability"

    /* Keywords (Definitions) */
    KEYWORD_DEF_CAP="defcap"
    KEYWORD_DEF_CONST="defconst"
    KEYWORD_DEF_PACT="defpact"
    KEYWORD_DEF_SCHEMA="defschema"
    KEYWORD_DEF_TABLE="deftable"
    KEYWORD_DEFUN="defun"

    /* Keywords (REPL) */
    KEYWORD_LOAD="load"

    /* Annotations */
    KEYWORD_DOC_ANNOTATION="@doc"
    KEYWORD_EVENT_ANNOTATION="@event"
    KEYWORD_MANAGED_ANNOTATION="@managed"
    KEYWORD_MODEL_ANNOTATION="@model"

    /* Literals */
    STR="regexp:(\"([^\"\\]|\\\"|\\)*\")"
    NUM="regexp:([0-9])"
    TRUE="true"
    FALSE="false"

    /* Identifiers */
    TICK="regexp:'[a-zA-Z][a-zA-Z0-9\-_]*"
    IDENTIFIER="regexp:[a-zA-Z][a-zA-Z0-9\-_]*"

    /* Operators (Arithmetic) */
    PLUS="+"
    MINUS="-"
    MULTIPLY="*"
    DIVIDE="/"
    POW="^"
    ABS="abs"
    CEILING="ceiling"
    FLOOR="floor"
    LOG="log"
    LN="ln"
    DECIMAL="dec"
    EXP="exp"
    MOD="mod"
    ROUND="round"
    SQRT="sqrt"

    /* Operators (Assignment) */
    BIND_ASSIGN=":="

    /* Operators (Bitwise) */
    BITWISE_AND="&"
    BITWISE_OR="|"
    BITWISE_REVERSE="~"
    BITWISE_SHIFT="shift"
    BITWISE_XOR="xor"

    /* Operators (Logical) */
    AND="and"
    AND_SHORT_CIRCUIT="and?"
    NOT="not"
    NOT_SHORT_CIRCUIT="not?"
    OR="or"
    OR_SHORT_CIRCUIT="or?"

    /* Operators (Relational) */
    EQUAL="="
    NOT_EQUAL="!="
    LESS_THAN="<"
    LESS_THAN_OR_EQUAL="<="
    GREATER_THAN=">"
    GREATER_THAN_OR_EQUAL=">="

    /* Delimiters */
    PAREN_OPEN="("
    PAREN_CLOSE=")"
    BRACE_OPEN="{"
    BRACE_CLOSE="}"
    BRACKET_OPEN="["
    BRACKET_CLOSE="]"
    COLON=":"
    COMMA=","
    DOT="."
    DYN_ACC="::"
  ]
}

MArgs ::= MArg*

MArg ::= IDENTIFIER ":" TypeDeclaration
       | IDENTIFIER

MTypeAnn ::= ":" TypeDeclaration











PactFVModels ::= PropExpressionList

PropExpressionList ::= PropExpression* // Was +
// https://github.com/kadena-io/pact-5/blob/master/pact-tests/pact-tests/fv-syntax-regression.repl

PropExpression ::= PropAtom
           | "(" PropExpressionList ")"
           | "[" PropExpressionList "]"

PropAtom ::= Variable
           | Number
           | String
           | FVKeyword
           | FVDelim
           | Boolean
           | Operator

FVKeyword ::= "let"
            | "lambda"
            | "if"
            | "progn"
            | "suspend"
            | "try"
            | "enforce"
            | "enforce-one"
            | "and"
            | "or"
            | "create-user-guard"
            | "with-capability"

FVDelim ::= "{"
          | "}"
          | ":"
          | ","




/* TODO: Final */

Program ::= !<<eof>> ProgramList
          | !<<eof>> ReplProgramList

/* Top Level */

ProgramList ::= TopLevel+

private TopLevel ::= Module
                   | Interface
                   | Use
                   | Expression { pin=1 }

/* Top Level (REPL) */

ReplProgramList ::= ReplTopLevel+

private ReplTopLevel ::= "(" ReplSpecial ")"
                       | "(" Defun ")"
                       | "(" DefConst ")"
                       | TopLevel { pin=1 }

ReplSpecial ::= KEYWORD_LOAD STR Boolean
              | KEYWORD_LOAD STR

/* Annotations & Documentation */

private MDocOrModel ::= DocumentationAnnotation ModelAnnotation
                      | ModelAnnotation DocumentationAnnotation
                      | DocumentationAnnotation
                      | ModelAnnotation
                      | DocumentationString

MDCapMeta ::= ManagedAnnotation
            | EventAnnotation

MModel ::= ModelAnnotation

MDoc ::= DocumentationAnnotation
       | DocumentationString

DocumentationAnnotation ::= KEYWORD_DOC_ANNOTATION STR

DocumentationString ::= STR

EventAnnotation ::= KEYWORD_EVENT_ANNOTATION

ManagedAnnotation ::= KEYWORD_MANAGED_ANNOTATION (IDENTIFIER ParsedName)*

ModelAnnotation ::= KEYWORD_MODEL_ANNOTATION "[" PactFVModels "]"

/* Module */

Module ::= "(" KEYWORD_MODULE IDENTIFIER Governance [MDocOrModel] (Definition | Extension)+ ")" { pin=7 }

ModuleNames ::= ModuleQualifier ("," ModuleQualifier)*  // Verified

private Governance ::= String
                     | IDENTIFIER

Interface ::= "(" KEYWORD_INTERFACE IDENTIFIER [MDocOrModel] (InterfaceDefinition | Use)+ ")" { pin=6 }

/* Extensions */

Extension ::= Use
            | "(" KEYWORD_IMPLEMENTS ModuleQualifier ")"
            | "(" KEYWORD_BLESS String ")"

Use ::= "(" KEYWORD_IMPORT ModuleQualifier STR? ImportList? ")"

ImportList ::= "[" [IDENTIFIER+] "]"

/* Definitions */

private Definition ::= DefCap
                     | DefConst
                     | DefPact
                     | DefSchema
                     | DefTable
                     | Defun

DefCap    ::= "(" KEYWORD_DEF_CAP IDENTIFIER [MTypeAnn] "(" [MArgs] ")" [MDocOrModel] [MDCapMeta] Block ")" { pin=10 }
DefConst  ::= "(" KEYWORD_DEF_CONST IDENTIFIER [MTypeAnn] Expression [MDoc] ")" { pin=2 }
DefPact   ::= "(" KEYWORD_DEF_PACT IDENTIFIER [MTypeAnn] "(" MArgs ")" [MDocOrModel] Steps ")" { pin=9 }
DefSchema ::= "(" KEYWORD_DEF_SCHEMA IDENTIFIER [MDocOrModel] SchemaArgumentList ")" { pin=2 }
DefTable  ::= "(" KEYWORD_DEF_TABLE IDENTIFIER ":" "{" ParsedName "}" [MDoc] ")" { pin=2 }
Defun     ::= "(" KEYWORD_DEFUN IDENTIFIER [MTypeAnn] "(" [MArgs] ")" [MDocOrModel] Block ")" { pin=9 }

SchemaArgumentList ::= SchemaArgument (SchemaArgument) * // Verified

SchemaArgument ::= IDENTIFIER (":" TypeDeclaration)?

/* Definitions (Interface) */

private InterfaceDefinition ::= IfDefCap
                              | DefConst
                              | IfDefPact
                              | DefSchema
                              | IfDefun

IfDefCap  ::= "(" KEYWORD_DEF_CAP IDENTIFIER [MTypeAnn] "(" MArgs ")" [MDocOrModel] [MDCapMeta] ")" { pin=10 }
IfDefPact ::= "(" KEYWORD_DEF_PACT IDENTIFIER [MTypeAnn] "(" MArgs ")" [MDocOrModel] ")" { pin=9 }
IfDefun   ::= "(" KEYWORD_DEFUN IDENTIFIER [MTypeAnn] "(" MArgs ")" [MDocOrModel] ")" { pin=9 }

/* Expressions */

// TODO: Refactor out.
Block ::= BlockBody
BlockBody ::= Expression+

Expression ::= "(" SymbolicExpression ")"
             | Variable
             | DataType

private upper SymbolicExpression ::= LambdaExpression
                                   | LetExpression
                                   | IfExpression
                                   | TryExpression
                                   | SuspendExpression
                                   | ProgNExpression
                                   | CapabilityExpression
                                   | GenericExpression

upper LambdaExpression ::= KEYWORD_LAMBDA "(" LambdaArguments ")" Block

LambdaArguments ::= LambdaArgument (LambdaArgument)*

LambdaArgument ::= IDENTIFIER (":" TypeDeclaration)?

upper LetExpression ::= KEYWORD_LET "(" Binders ")" Block

//Binders ::= Binder (Binder)* // Verified
//Binder ::= "(" IDENTIFIER [MTypeAnn] Expression ")" // Type annotation fault
//Binders ::= Binder+ // Verified

Binders ::= ("(" IDENTIFIER [MTypeAnn] Expression ")")+

upper IfExpression ::= KEYWORD_IF Expression Expression Expression

upper TryExpression ::= KEYWORD_TRY Expression Expression

upper SuspendExpression ::= KEYWORD_SUSPEND Expression

upper ProgNExpression ::= KEYWORD_BLOCK_INTRO BlockBody

upper CapabilityExpression ::= CapabilityForm

CapabilityForm ::= KEYWORD_WITH_CAPABILITY Expression Block
                 | KEYWORD_CREATE_USER_GUARD "(" ParsedName AppList ")"

AppList ::= Expression* // Was +

upper GenericExpression ::= Expression AppBindList // Check * ?

AppBindList ::= (Expression | BindingForm)*

BindingForm ::= "{" BindPairs "}"

BindPairs ::= BindPair ("," BindPair)*

BindPair ::= STR ":=" MArg
           | TICK ":=" MArg

/* Steps */

Steps ::= Step+

Step ::= "(" KEYWORD_STEP Expression [MModel] ")"
       | "(" KEYWORD_STEP Expression Expression [MModel] ")"
       | "(" KEYWORD_STEP_WITH_ROLLBACK Expression Expression [MModel] ")"
       | "(" KEYWORD_STEP_WITH_ROLLBACK Expression Expression Expression [MModel] ")"

/* Variables & Names */

Variable ::= IDENTIFIER "." ModuleQualifier
           | IDENTIFIER "::" IDENTIFIER
           | IDENTIFIER

ParsedName ::= IDENTIFIER "." ModuleQualifier
             | IDENTIFIER "::" IDENTIFIER
             | IDENTIFIER

ParsedTypeName ::= IDENTIFIER "." ModuleQualifier
                 | IDENTIFIER

ModuleQualifier ::= IDENTIFIER "." IDENTIFIER
                  | IDENTIFIER

/* Data Types */

TypeDeclaration ::= "[" TypeDeclaration "]"
                  | "module" "{" ModuleNames "}"
                  | IDENTIFIER "{" ParsedTypeName "}"
                  | IDENTIFIER

DataType ::= CompositeDataType
           | AtomicDataType
           | "(" ")"

CompositeDataType ::= List
                    | Object

AtomicDataType ::= Number
                 | String
                 | Boolean

/* Data Types (Composite) */

List ::= "[" [ListExpression] "]"

ListExpression ::= Expression MCommaExpression? // Check * ?

// TODO: Rename.
MCommaExpression ::= "," ExpressionCommaSep
                   | AppList

ExpressionCommaSep ::= Expression ("," Expression) * // Verified

Object ::= "{" ObjectBody? "}"

ObjectBody ::= FieldPair ("," FieldPair)*

FieldPair ::= STR ":" Expression
            | TICK ":" Expression

/* Data Types (Atomic) */

Number ::= Integer
         | FloatingPoint

Integer ::= ["+" | "-"] NUM+

FloatingPoint ::= ["+" | "-"] NUM+ "." NUM+

String ::= STR
         | TICK

Boolean ::= TRUE
          | FALSE

/* Operators */

Operator ::= ArithmeticOperator
           | AssignmentOperator
           | LogicalOperator
           | RelationalOperator
           | BitwiseOperator

ArithmeticOperator ::= PLUS
                     | MINUS
                     | MULTIPLY
                     | DIVIDE
                     | POW
                     | ABS
                     | CEILING
                     | FLOOR
                     | LOG
                     | LN
                     | DECIMAL
                     | EXP
                     | MOD
                     | ROUND
                     | SQRT

AssignmentOperator ::= BIND_ASSIGN

BitwiseOperator ::= BITWISE_AND
                  | BITWISE_OR
                  | BITWISE_REVERSE
                  | BITWISE_SHIFT
                  | BITWISE_XOR

LogicalOperator ::= AND
                  | AND_SHORT_CIRCUIT
                  | NOT
                  | NOT_SHORT_CIRCUIT
                  | OR
                  | OR_SHORT_CIRCUIT

RelationalOperator ::= EQUAL
                     | NOT_EQUAL
                     | LESS_THAN
                     | LESS_THAN_OR_EQUAL
                     | GREATER_THAN
                     | GREATER_THAN_OR_EQUAL
